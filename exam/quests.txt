# Ядро і програма (20)

Ядро ОС — це:
+ Програма, яка запускається першою при старті системи
+ Програма, яка працює з найвищим рівнем привілеїв в ОС
- Програма, записана в прошивку (firmware), яка запускається при старті системи
- Особлива частина ОС, яка не є програмою, але керує роботою комп'ютера

Принципи побудови архітектури Фон-Неймана включають наступні:
+ Двійкового кодування
+ Адресованість пам'яті
- Динамічності архітектури (апаратної топології і набору команд процесора)
- Розділеності даних і програмного коду в пам'яті

До статичної пам'яті програми відносяться:
- Стек (stack)
+ Секція даних (data section)
+ Секція тексту програми (text section)
- Cекція даних, що відображаються у пам'ять (memory-mapped region)

Бінарний інтерфейс додатків (ABI) ОС включає в себе:
+ Специфікацію типів даних
+ Формати виконуваних файлів
+ Специфікацію угод про виклики
- Специфікацію методів міжпроцесної взаємодії (IPC)

Системний виклик — це:
- Процедура в програмі, яка здійснює взаимодію з ОС
+ Процедура ОС, доступна для виклику користувацьким программам через особливий інтерфейс
- Внутрішня процедура ядра ОС, доступна для виклику тілько іншим підсистемам ядра
- Процедура ядра ОС, призначена для взаємодії між підсистемами ядра

Системний виклик в архітектурі x86 можна здійснити за допомогою:
- Інструкції SYSCALL
- Інструкції CALL, як і для звичайних функцій
+ Програмного переривання (INT 80 у Unix)
+ Інструкції SYSENTER

До програмних переривань-виключних ситуацій (Exceptions) відносятся:
+ помилки (fault)
+ ловушки (trap)
+ збої (abort)
- сигнали (signal)

В комп'ютері розрізняють такі контексти виконання програми:
- процесорний
+ атомарний
+ ядерний
- зовнішній

Завантаження ОС відбувається в такі етапи:
+ Завантаження прошивки, Вибір ОС для завантаження, Виконання програми-завантажувальника ОС, Завантаження ядра ОС, Завантаження компонентів ОС в користувацькому середовищі
- Вибір ОС для завантаження, Виконання програми-завантажувальника ОС, Завантаження прошивки, Завантаження ядра ОС, Завантаження компонентів ОС в користувацькому середовищі
- Вибір ОС для завантаження, Завантаження прошивки, Виконання програми-завантажувальника ОС, Завантаження ядра ОС, Завантаження компонентів ОС в користувацькому середовищі
- Вибір ОС для завантаження, Виконання програми-завантажувальника ОС, Завантаження прошивки, Завантаження компонентів ОС в користувацькому середовищі, Завантаження ядра ОС

Кільця процесора (CPU rings) в архітектурі x86 слугують для:
+ Розмежування привілеїв програм при доступі до різних сегментів пам'яті
- Підтримки реалізації кешу процесора різних рівнів (L1, L2, L3)
- Підтримки роботи сторінкової системи віртуальної пам'яті
- Розмежування привілеїв програм при доступі до різних функцій процесора

Регістр таблиці дескрипторів переривань (IDT) слугує для того щоб:
- Знайти потрібну процедуру для обробки переривання по номеру переривання
+ Знайти в пам'яті таблицю покажчиків на процедури обробки переривань
- Зберігати таблицю покажчиків на процедури обробки переривань
- Передати управління в процедуру обробки переривання

До динамічної пам'яті програми відносяться:
+ Стек (stack)
- Секція даних (data section)
+ Купа (heap)
+ Cекція даних, що відображаються у пам'ять (memory-mapped region)

Cекція даних, що відображаються у пам'ять (memory-mapped region) використовуватись для:
+ Спільного використання одного блоку пам'яті декількома програмами
- Роботи з пам'яттю як з файлом (з модливістю виконання операцій open/close)
+ Роботи з файлами як з пам'яттю, а не через файловий інтерфейс
- Роботи зі статичною пам'яттю як з динамічною

Угода про виклики регламентує наступні питання:
- Кількість аргументів, з якими може викликатися процедура і їх типи
+ Як передаються і повертаються значення при виклику процедури
+ Хто виконує очистку стеку: викликаюча чи викликаєма процедура
- Як передається управління між виклюкаючою і викликаємою процедурою

Аргументи при виклику функції в різних угодах про виклики можуть передаватись:
- Через купу
+ Через стек
+ Через регістри
- Через кеш процесора

До бінарних виконуваних файлів не належать:
- Об'єктні файли (object file)
- Виконувані програми (executable)
- Розділяємі бібліотеки (shared library)
+ Скрипти (script)

Регістр покажчика на стек в архітектурі x86 називається:
- EAX
- Instruction Pointer (IP)
+ Stack Pointer (SP)
- Stack Segment (SS)

В архітектурі x86 регістр, значення якого не можуть змінювати користувацькі програми безпосередньо це:
+ Instruction Pointer (IP)
- Stack Pointer (SP)
- EBX
- COde Segment (CS)

До регістрів загальному призначення в архітектурі x86 відносяться регістри:
- Instruction Pointer (IP)
- Stack Pointer (SP)
+ ECX
- Interrupt Descriptor Table (IDT)

Наступні операції є складовими виконання введення-виведення ОС:
+ Переривання, яке надсилає пристрій після завершення операції
- Переривання, яке надсилає пристрій перед початком операції
+ Копіювання даних з області пам'яті ядра у область пам'яті програми
+ Обробка переривання драйвером пристрою


# Пам'ять і кеш (16)

До стандартних алгороитмів виділення пам'яті відносяться:
+ Алгоритм близнбків
- Алгоритм перший прийшов-перший обслужений
+ Алгоритм перший підходящий
- Алгоритм випадкового вибору

Віртуальна пам'ять включає наступні механізми управління пам'яттю:
+ Сторінкова модель пам'яті
+ Сегментна модель пам'яті
- Модель прямого доступу до пам'яті
- Модель доступу до файлів, що відображаться в пам'ять

До алгоритмів заміщення записів у кеші відносятся такі алгоритми:
+ Годинник
- Лічильник
- Останнього шансу
+ Не часто використовуваний (NFU)

Сторінкова організація віртуальної пам'яті працює таким чином:
+ Розділяє логічну адресу на дві частини, одна з яких перетворюється за допомогою таблиці сторінок, а інша залишається без змін
- Розділяє логічну адресу на дві частини, одна з яких перетворюється за допомогою таблиці сторінок, а інша додається до неї
- Додає до логічної адреси базову адресу сторінки
- Віднімає від логічної адреси базову адресу сторінки

Сегментна організація віртуальної пам'яті працює таким чином:
- Розділяє логічну адресу на дві частини, одна з яких перетворюється за допомогою таблиці сторінок, а інша залишається без змін
- Розділяє логічну адресу на дві частини, одна з яких перетворюється за допомогою таблиці сторінок, а інша додається до неї
+ Додає до логічної адреси базову адресу сегмента
- Віднімає від логічної адреси базову адресу сегмента

Підходи до оптимізації сторінкової організації пам'яті включають використання:
- Файлу підкачки
+ Багаторівневої таблиці сторінок
+ Кешу сторінок TLB
+ Інвертованої таблиці сторінок

Фрагментація буває:
+ Внутрішня
- Проміжна
+ Зовнішня
- Безпосередня

Зовнішня фрагментація — це неможливість використання:
- Окремих частин деяких блоків пам'яті
+ Окремих блоків пам'яті
- Групи блоків пам'яті
- Всіх блоків пам'яті

Внутрішня фрагментація — це неможливість використання:
+ Окремих частин деяких блоків пам'яті
- Окремих блоків пам'яті
- Групи блоків пам'яті
- Всіх блоків пам'яті

Свопінг — це:
- Завантаження даних з пам'яті у кеш процесора для пришведшення роботи програми
- Завантаження даних з диску у дисковий кеш наперед для пришвидшення читання даних з диску
+ Вивантаження сторінки пам'яті на диск для тимчасового розширення місткості пам'яті
- Вивантаження даних з дискового кешу у пам'ять для його звільнення

Алгоритм близнюків для виділення пам'яті (buddy allocation) обирає для виділення:
- Перший підходящий вільний блок
- Найбільший по розміру з підходящих вільних блоків
- Найменший по розміру з підходящих вільних блоків
+ Перший вільний блок, розмір якого є ступенню двійкі, що не менше за потрібний об'єм пам'яті

У 32-розрядній архітектурі при використанні сторінкової організації пам'яті не можлива наступна адреса сторінки:
- 0xFF
- 0xFFFF
+ 0xFFFFFFFF
- 0xFFFFFF

До адрес пам'яті відносять:
+ Фізичні адреси
+ Лінійні адреси
+ Логічні адреси
- Абстрактні адреси

Наскрізний (write-through) кеш передбачає що:
+ Дані записуються як в кеш, так і в пам'ять одночасно
- Дані читаються як з кешу, так і з пам'яті одночасно
- Дані записуються в кеш і періодично синхронізуються в пам'ять
- Дані читаються з кешу, а записуються в пам'ять

Кеш зі зворотнім записом (write-back) передбачає що:
- Дані записуються як в кеш, так і в пам'ять одночасно
- Дані читаються як з кешу, так і з пам'яті одночасно
+ Дані записуються в кеш і періодично синхронізуються в пам'ять
- Дані читаються з кешу, а записуються в пам'ять

До алгоритмів заміщення записів у кеші не відноситься алгоритм:
- Не використовуаний нещодавна (LRU)
- Не використовуваний часто і нещодавно (LRFU)
+ Не використовуваний найдовше (LLU)
- Не використовуваний часто (LFU)


# Процеси & IPC (20)

В моделі породження процесів методом клонування в Unix:
- Породження процессу вимагає виконання системного виклику exec
+ Породження процессу вимагає виконання системного виклику fork, після якого може бути виконаний виклик exec для зміни програми, яка виконується
- Породження процессу вимагає виконання системного виклику fork, за яким обов'язково має виконуватись виклик exec
- Породження процессу вимагає виконання системного виклику fork_exec

В життєвому циклі процесу можливі переходи між наступними станами:
- Зі стану породження у стан завершення
- Зі стану породження у стан заблокований
- Зі стану заблокований у стан виконання
+ Зі стану заблокований у стан готовності

В життєвому циклі процесу не можливий перехід між наступними станами:
- Зі стану виконання у стан завершення
+ Зі стану породження у стан заблокований
- Зі стану готовності у стан виконання
- Зі стану заблокований у стан готовності

Переривання планувальника CLOCK INTERRUPT переводить процес:
- Зі стану виконання у стан заблокований
- Зі стану породження у стан готовності
+ Зі стану виконання у стан готовності
- Зі стану породження у стан виконання

Ці події можуть переводити процес зі стану виконання у стан заблоковний:
- Переривання планувальника CLOCK INTERRUPT
+ Виконання програмою блокуючої операції, наприклад read
- Сигнал про завершення дочірнього процесу
- Завершення виконання блокуючої операції, наприклад read

Ці події можуть переводити процес зі стану заблоковний у стан готовності:
- Переривання планувальника CLOCK INTERRUPT
- Виконання програмою блокуючої операції, наприклад read
+ Сигнал про завершення дочірнього процесу
+ Завершення виконання блокуючої операції, наприклад read

Ці події можуть переводити процес зі стану виконання у стан готовності:
+ Переривання планувальника CLOCK INTERRUPT
- Виконання програмою блокуючої операції, наприклад read
- Сигнал про завершення дочірнього процесу
- Завершення виконання блокуючої операції, наприклад read

В Unix-системах у разі відправки процесу сигналу SIG_TERM за допомогою системного виклику або утиліти kill:
- Процес завершує себе
- ОС одразу примусово завершує процес
+ Процес може обробити цей сигнал і завершуватись або не завершуватись на свій розсуд, але якщо він не обробить сигнал, то система сама завершить його
- ОС примусово завершує процес, але спочатку дає йому шанс звільнити ресурси і завершитись коректно

В Unix-системах у разі відправки процесу сигналу SIG_KILL за допомогою системного виклику або утиліти kill:
- Процес завершує себе
+ ОС примусово завершує процес, бо цей сигнал неможливо обробити програмно
- Процес може обробити цей сигнал і завершуватись або не завершуватись на свій розсуд, але якщо він не обробить сигнал, то система сама завершить його
- ОС примусово завершує процес, але спочатку дає йому шанс звільнити ресурси і завершитись коректно

В Unix-системах у разі, якщо процес не обробляє сигнал, який йому було надіслано за допомогою системного виклику або утиліти kill:
+ ОС примусово завершує його
- Нічого не відбувається
- ОС надсилає сигнал повторно
- Процес блокується

Процес-зомбі — це процес:
- Який не хоче завершуватись
+ Батьківський процес якого вже завершено
- Дочірні процеси якого ще не завершились
- Який завершився з помилкою

Після завершення процесу його код повернення (який є аргументом системного виклику exit):
- Стирається
+ Залишається доступним для зчитування батьківського процесу з використанням системного виклику waitpid
- Передається у батьківський процес за допомогою сигналу SIG_CHILD
- Друкується в консоль

Модель fork-exec породження процесу:
- Клонує управляючу структуру батьківського процесу методом запису на місці (in-place modification) після чого підміняє його дочірнім процесом
+ Клонує управляючу структуру батьківського процесу методом копіювання при записі (copy-on-write) після чого підміняє його дочірнім процесом
- Завантажує управляючу структуру процеса з файлу після чого завантажує дочірній процес
- Підміняє батьківський процес дочірнім процесом, після цого копіює його управляючу структуру методом запису на місці (in-place modification)

Перемикання контексту — це проміжок часу:
+ Коли управління передається від одного процесу іншому процесу
+ Коли ОС зберігає контекст виконання поточного процесу і відновлює контекст виконання наступного процесу, після чого передає йому управління
- Коли ОС завершує поточний процеc і завантажує наступний процес, після чого передає йому управління
- Коли процес зберігає свій контекст, після чого передає управління наступному процесу, який відновлює свій контекст і розпочинає роботу

До алгоритмів планування процесів зі статичним пріоритетом відносяться такі алгоритми:
+ Перший прийшов, перший обслужений (FCFS)
- Алгоритм справедливого планування
- Багаторівнева черга зі зворотнім зв'язком (MLFQ)
+ Карусель (RR)

В Unix-системах при використанні анонімного каналу PIPE для взаємодії між процесами:
- Дані можуть передаватися в обидва боки
- Дані передаються пакетами спеціального формату
+ Один процес може тільки писати в канал, а інший тільки читати
+ Помилка в каналі призводить до відправки сигналу SIG_PIPE процесу, який намагався виконати операцію читання або запису

До блокуючих операцій відносяться наступні:
+ Введення-виведення (read/write)
+ Очікування на семафорі (sem_wait)
- Розблокування мьютексу (mutex_unlock)
- Системний виклик exit 

При виконанні блокуючого системного виклику:
- Процес засинає і передає управління іншому процесу
- ОС переводить процес у стан заблокований і передає управління іншому заблокованому процесу
+ ОС переводить процес у стан заблокований і передає управління одному з процесів, який знаходиться у стані готовності
- ОС блокує процес, якщо є інші процеси, які очікують, в іншому разі — продовжує його виконання

Процес (process) і нитка управління (thread) відрізняються наступнимими характеристиками:
+ Процес може мати багато ниток, а нитка відноситься тільки до одного процеса
- Нитка має свій контекст, який включає дескриптори відкритих файлів, сокетів, встановлені обробники сигналів і т.і.
- Одна нитка може бути прив'язаною до декількох процесів, а процес може бути прив'язаним лише до однієї нитки
- Навідміну від процесів, нитки не управляються планувальником ОС

Рідні (native) і легковагі/зелені (lightweight/green) нитки відрізняються тим, що:
+ ОС не знає нічого про легковагі нитки, але знає про рідні
- ОС не знає нічого про рідні нитки, але знає про легковагі
- Рідні нитки працюють в рамках одного процесу, а легковагі — різних
- Легковагі нитки працюють в рамках одного процесу, а рідні — різних


# Синхронізація (14)

Умови гонок — це стан системи:
+ В якому результат роботи залежить від послідовності, в якій будуть працювати окремі процеси, і цю послідовність не можливо передбачити
- При якому виконається тільки той процес, який закінчиться раніше
- В якому результат роботи залежить тільки від швидкості виконання процесів в ній
- В якому результат роботи залежить від послідовності, в якій будуть працювати окремі процеси, і ця послідовність задана за допомогою програмних механізмів синхронізації

Спінлок — це:
- Двійковий семафор
- Змінна-замок, реалізована в користувацькій програмі
- Апаратний механізм синхронізації
+ Системний механізм синхронізації, який використовує зайняте очікування (busy waiting)

Критична секція — це стан процесу, в якому:
- В ОС заборонені переривання
- Він обробляє критичні дані
+ Він звертається до даних, які також використовують інші процеси
- В ньому відбулась помилка і він може завершитись

Взаємне блокування (deadlock) може виникнути в наступній ситуації:
- Процеси не використовують синхронізацію
+ Процеси взаємодіють за допомогою передачі повідомлень і очікують повідомлення один від одного
+ Процеси використовують одночасно декілка спільних семафорів, доступ до яких здійснюють випадковим чином
- Процеси використовують єдиний спільний примітив синхронізації

До способів запобігання взаємних блокувань (deadlock) відносяться:
+ Використання монітору дедлоків
- Недопущення, щоб процес одночасно блокував декілька замків
+ Нумерація замків і дозвіл на блокування їх тільки в порядку зростання номера
+ Алгоритм банкіра

Зайняте очікування (busy waiting) — це:
- Механізм синхронізації, при використанні якого процес очікує завершення іншого процесу
+ Метод очікування, при якому процес постійно перевіряє умови завершення і нічого більше не робить
- Метод очікування, при якому процес засинає, поки не настане умова завершення, після чого його знову запускає ОС
- Метод очікування, при якому процес виконує корисну роботу і періодично перевіряє умову завершення

Операція інкременту (у мові С: ++) створює умову гонок, бо:
- Вона є атомарною
+ Вона не є атомарною і потребує декількох інструкцій процесора для виконання
+ В ній відбувається звертання до блоку пам'яті, до якого можуть мати доступ інші потоки
- Мова С не призначена для написання багатопотокових програм

Мьютекс — це:
- Семафор з лічильником, що рахує з нуля
- Двійковий апаратний примітив синхронізації
- Двійковий монітор
+ Двійковий семафор, операцію down для якого має виконувати тільки той самий процес, який виконав операцію up

Модель акторів володіє наступними властивостями:
- Актори — це рідні (native) процеси ОС
+ Актори не мають спільної пам'яті і взаємодіють тільки через передачу повідомлень
- Актори можуть взаємодіяти через передачу повідомлень або спільну пам'ять
+ Актори відправляють і обробляють повідомлення асинхронно

Системні механізми синхронізації — це:
- Спеціальні апаратні інструкції, які призначені для синхронізації
+ Системні виклики, які призначені для синхронізації
- Алгоритми синхронізації, які можна реалізувати в користувацькій програмі
- Механізми синхронізації, яки використовують спеціальну підсистему ОС, призначену для синхронізації

Примітив синхронізації семафор володіє наступними властивостями:
- Дозволяє доступ до критичної області тільки одному процесу
- Процеси очікують на семфорі у режимі зайнятого очікування (busy waiting)
+ Операція down на семафорі зменшує його лічильник на 1, тільки якщо він більше 0, інакше процес переходить в режим очікування на семафорі
- Операція up на семафорі збільшує його лічильник на 1, тільки якщо він дорівнює 0, інакше процес переходить в режим очікування на семафорі

Інверсія приоритетів — це ситуація, коли:
+ Процес з меншим пріоритетом отримує доступ до ресурсу раніше процесу з більшим пріоритетом
+ Процес з більшим пріоритетом чекає процесу з меншим пріоритетом
- Процеси з однаковим пріоритетом почергово отримують доступ до ресурсу
- Процес з меншим пріоритетом не може продовжити роботу, оскільки його постійно витісняє процес з більшим пріоритетом

До апаратних інструкцій синхронізації відносяться:
+ Test and set lock (TSL)
+ Compare and swap (CAS)
- sem_wait
- SYSENTER

Неблокуюча синхронізація — це група підходів до синхронізації, яка використовує:
- Семафори, мьютекси та інші стандартні механізми синхронізації
+ Обмін повідомленнями з використанням спеціальних механізмів (каналів, поштових скриньок)
- Тільки апаратні примітиви синхронізації, такі яка CAS
- Спеціальні системні виклики, такі як fork і wait


# Файли, мережа, безпека (19)

До операцій, які можуть виконуватися над файлами, відносяться наступні:
+ getattr
- link
- readdir
+ read

До операцій, які можуть виконуватися над директоріями, відносяться наступні:
+ getattr
+ link
+ readdir
- read

Системний виклик dup2 використовується для того, щоб:
- клонувати файловий дескриптор
+ прив'язати (перенаправити) один файловий дескриптор до потоку, на який вказує другий файловий дескриптор
- створити копію файлового дескриптора
- перенаправити файловий дескриптор у потік вводу-виводу

Файловий дескриптор — це:
- Інша назва для імені файлу
- Унікальний номер файлу в ОС
+ Унікальний для процесу номер файлу, який зберігається в таблиці ОС
- Ідентифікатор, який користувацька програма присвоює файлу під час його відкриття

Яка схема розміщення файлів має найбільшу швидкодію:
+ Послідовна
- За допомогою зв'язного списку
- Таблична
- Індексна

Наступні схеми розміщення файлів страждають на внутрішню фрагментацію:
+ Послідовна
+ За допомогою зв'язного списку
+ Таблична
+ Індексна

Наступні схеми розміщення файлів страждають на зовнішню фрагментацію:
+ Послідовна
- За допомогою зв'язного списку
- Таблична
- Індексна

Монтування ФС в Unix-системах — це:
- Створення нового кореня ФС і підлючення до нього всіх ФС, доступних в поточний час
- Створення точки входу, через яку можна звернутись до ФС
- Підлючення зовнішнього диску як окремого пристрою в системі
+ Підключення ФС до загального дерева директорій ОС

До інтерфейсу BSD-сокетів відносяться наступні операції:
+ connect
- mount
- reject
+ accept

Операція listen інтерфейсу BSD Sockets виконує наступну дію:
- Прив'язує сокет до порта ОС
- Приймає підключення від клієнта
+ Переводить сокет у режим прослуховування підключень
- Виконує підключення до серверу

Операція connect інтерфейсу BSD Sockets виконує наступну дію:
- Прив'язує сокет до порта ОС
- Зв'язує між собою клієнтський і серверний сокети
- Переводить сокет у режим прослуховування підключень
+ Виконує підключення до серверу

Операція bind інтерфейсу BSD Sockets виконує наступну дію:
+ Прив'язує сокет до порта ОС
- Зв'язує між собою клієнтський і серверний сокети
- Переводить сокет у режим прослуховування підключень
- Виконує підключення до серверу

Операція accept інтерфейсу BSD Sockets виконує наступну дію:
- Прив'язує сокет до порта ОС
+ Зв'язує між собою клієнтський і серверний сокети
- Переводить сокет у режим прослуховування підключень
- Виконує підключення до серверу

Для організації з'єднання з використанням інтерфейсу BSD Sockets необхідно виконати наступні дії:
- На сервері операцію listen, потім bind. Після цього на клієнті операцію connect
+ На сервері операцію bind, потім listen. Після цього на клієнті операцію connect, а на сервері — accept
- На сервері операцію connect, потім listen. Після цього на клієнті операцію bind, а на сервері — accept
- На сервері операцію listen, потім bind, потім accept. Після цього на клієнті операцію connect

Які рівні моделі мережевих протоколів OSI відустні у стеку мережевих протоколів TCP/IP:
- Транспортний
- Міжмережевий
+ Сеансовий
- Прикладний

Які з наведених рівнів включає стек мережевих протоколів TCP/IP:
+ Транспортний
- Представлення
+ Фізичний
+ Канальний

До механізмів реалізацї системи комп'ютерної безпеки выдносяться:
+ Списки котролю доступу (ACL)
- Системи розмежуання прав
+ Мандати
- Жетони

Основними загрозами для безпеки комп'ютерної системи є:
+ Несанкціонований доступ
+ Порушення нормальної роботи системи
+ Псування даних, що обробляються або зберігаються цією системою
- Використання системи для цілей, для яких вона не пристосована

До принципів створення безпечних систем відносяться:
+ Принцип валідації зовнішніх даних
+ Принцип психологічної прийнятності
- Принцип максимальної секретності
- Принцип справедливості
