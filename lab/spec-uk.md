## Завдання

Необхідно написати програму на мові C в середовищі Linux, яка виконує індивідуальне завдання. Ця программа повинна використовувати утиліти Shell для обробки даних у файлі `log.txt` (`cat`, `grep`, `sort`, `head`, `awk`, `uniq`, `cut`, `paste` і т.д.), але логіка пов'язування цих програм між собою має бути реалізована за допомогою операторів мови С і системних викликів (обов'язковим є використання викликів `fork`, варіантів виклику `exec`, `wait` або `waitpid`, `pipe`, `dup2`). Під цією логікою мається на увазі:

- запуск процесів і очікування їх результатів
- відкриття файлів, перенаправлення вводу-виводу, pipe
- умовні вирази і цикли

Приклад подібної програми наведено нижче.

Файл `log.txt` складається з записів, кожен з яких займає один рядок.

Приклад запису:

    host-24-225-218-245.patmedia.net - [01/Oct/2006: 6:33:45 -0700] "GET / example / example.atom HTTP/1.1" 304 - "-" "NetNewsWire / 2.0b37 (Mac OS X; Lite; http://ranchero.com/netnewswire/) "

Формат запису:

    Хост клієнта - [Штамп часу з часовою зоною] Рядок HTTP-запиту (тип, URL, версія) Код HTTP-відповіді Кількість переданих байт або '-', якщо відповідь не має тіла Рядок реферера ('-' означає прямий запит без реферера) Назва клієнта (браузер)

Розшифровка:

**01/Oct/2006: 6:33:45 -0700** з хоста **host-24-225-218-245.patmedia.net** по протоколу **HTTP/1.1** був здійснений запит типу **GET** для отримання ресурсу, що перебуває по посиланню **/example/example.atom**. Код відповіді на запит від сервера: **304**. Така відповідь не передбачає наявності тіла відповіді (кількість переданих байт - **0**). Запит виконувався безпосередньо, а не по посиланню з іншого сайту (поле реферер - порожнє). Кліент використовував для звернення програму **NetNewsWire/2.0b37**, ОС клієнта: **Mac OS X**

## Системні виклики

Системні виклики в UNIX-системах — це інтерфейс, через який ОС надає сервіси користувацкій програмі. Вони реалізують такі функції, як:

- управління вводом-виводом
- робота з файлами
- управління процесами
- управління механізмами IPC
- управління пам'яттю
- робота з мережею
- і т.і.

Стандартна бібліотека С, а також інших мов програмування, реалізує свої функції у наведених сферах (наприклад, роботу з файлами і ввод-вивід) як обгортки навколо системних викликів. Але з системними викликами можна працювати напряму, в обхід стандартної бібліотеки. Більш того, не всі системні виклики мають аналоги в стандартній бібліотеці: функції управління процесами, роботи з сокетами і нитками управління є прикладами таких функцій. 

Нехай нам необхідно вирішити наступну задачу: знайти в текстовому файлі `1.txt` всі рядки, які містять в собі дату `1/01/2000`. В UNIX середовищі це можна зробити за допомогою такого конвеєру: `cat 1.txt | grep 1/01/2000`. Нижче наведений приклад програми на мові С з використанням системних викликів, яка реалізує те ж саме.

	#include <sys/types.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <stdlib.h>
	
	int main() {
        int fd[2], status;

		/* Створюємо анонімний канал */
	    pipe(fd);

	    /* Клонуємо поточний процес */
	    pid_t pid1 = fork();
	
	    /* Зверніть увагу на те, що змінна pid буде існувати і  оригінальному
		 * процесі, і в його клоні, але в другому випадку буде дорівнювати
	     * нулю. Саме цей факт використовується в наступній конструкції */

	    if (!pid1) { // childpid == 0 => це породжений процес
			
			/* В цьому процесі ми будемо записувати в канал */
			dup2(fd[1], 1); // перенапрявляємо STDOUT (fd==1) поточного процесу у канал
			close(fd[0]);
			close(fd[1]);
	
			/* Запускаємо cat */
	        char* command[3] = {"/bin/cat", "1.txt", NULL};
	        execvp(command[0], command);
	
	        /* Якщо не відбулося ніяких помилок, execvp() не завершується і ми
	         * ніколи не досягнемо цієї ділянки коду. Якщо ж ми все-таки сюди
	         * дістались, клону слід завершитися з кодом повернення,
	         * який сигналізує про помилку */
	        exit(EXIT_FAILURE);

	    } else if (pid1 == -1) {
	        /* fork() повертає -1 у випадку помилки */
	        fprintf(stderr, "Can't fork, exiting...\n");
	        exit(EXIT_FAILURE);
	    }

	    /* Це батьківський процес */

		/* Клонуємо його знову */
	    pid_t pid2 = fork();

	    if (!pid2) { 
			
			/* В цьому процесі ми будемо зчитувати з каналу */
			dup2(fd[0], 0); // перенапрявляємо вивід каналу у STDIN (fd==0) поточного процесу
			close(fd[0]);
			close(fd[1]);
	
			/* Запускаємо grep */
	        char* command[3] = {"/bin/grep", "1/01/2010", NULL};
	        execvp(command[0], command);
	
	        exit(EXIT_FAILURE);

	    } else if (pid2 == -1) {
	        fprintf(stderr, "Can't fork, exiting...\n");
	        exit(EXIT_FAILURE);
	    }


	    /* Це батьківський процес */

		/* Закриваємо пайп */
		close(fd[0]);
		close(fd[1]);

		/* Очікуємо завершення породжених процесів */
		waitpid(pid1, NULL, 0);
		waitpid(pid2, &status, 0);
	    
		/* Завершуємося з кодом повернення grep */
		exit(status);
	    
	    return 0;
	}

Під час роботи з системними викликами обов'язково необхідно обробляти код повернення з них, оскільки інформація про помилки, які могли відбутися у виклику повертається у цьому коді.

Отримати докладну справку по системним викликам можна за допомогою `man` — ним присвячений розділ 2 (наприклад, ввівши в консолі `man 2 fork` можна отримати справку про системний виклик `fork`).

:br

## Література

### Компіляція, відлагодження і збирання програм в UNIX-середовищі

- <http://users.actcom.co.il/~choo/lupg/tutorials/>
- <http://www.delorie.com/gnu/docs/gdb/gdb.html>
- <http://dirac.org/linux/gdb/>
- <http://www.gnu.org/software/make/manual/make.html>
- <https://www.hackerschool.com/blog/5-learning-c-with-gdb>
- <http://sysadvent.blogspot.com/2010/12/day-15-down-ls-rabbit-hole.html>

### Системні виклики для запуску процесів і управлінням вводом-виводом

- <http://ro-che.info/docs/2010-10-22-posix.pdf>
- <http://www.advancedlinuxprogramming.com/alp-folder/alp-ch03-processes.pdf>
- <http://www.yolinux.com/TUTORIALS/ForkExecProcesses.html>
